#!/usr/bin/env python3
"""
VulnForge Exploit Generator Module
Generates and validates exploits using AI
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
import ast
import re
from datetime import datetime

class ExploitGenerator:
    def __init__(self, base_dir: Path, llm_engine: Any):
        self.base_dir = base_dir
        self.llm = llm_engine
        self.logger = logging.getLogger(__name__)
        self.exploit_dir = self.base_dir / "data" / "exploit_db"
        self.exploit_dir.mkdir(parents=True, exist_ok=True)
        
    def generate_exploit(self, cve_data: Dict, recon_data: Dict) -> Dict[str, Any]:
        """Generate exploit based on CVE and recon data"""
        # Prepare prompt with context
        prompt = self._build_exploit_prompt(cve_data, recon_data)
        
        # Get AI response
        response = self.llm.query(
            prompt=prompt,
            system_prompt="""You are a security researcher creating proof-of-concept exploit code.
            Generate safe, educational exploit code with proper error handling and comments.
            Include safety warnings and ethical use disclaimers."""
        )
        
        if not response:
            return {"error": "Failed to generate exploit"}
            
        # Parse and validate the response
        exploit_data = self._parse_exploit_response(response)
        if not exploit_data:
            return {"error": "Failed to parse exploit response"}
            
        # Save the exploit
        exploit_path = self._save_exploit(exploit_data, cve_data)
        exploit_data["file_path"] = str(exploit_path)
        
        return exploit_data
        
    def _build_exploit_prompt(self, cve_data: Dict, recon_data: Dict) -> str:
        """Build prompt for exploit generation"""
        return f"""
        Generate a proof-of-concept exploit for this vulnerability:
        
        CVE: {cve_data.get('cve_id', 'Unknown')}
        Description: {cve_data.get('description', 'Unknown')}
        Affected Software: {cve_data.get('affected_software', 'Unknown')}
        CVSS Score: {cve_data.get('cvss_score', 'Unknown')}
        
        Target Information:
        - IP: {recon_data.get('ip', 'Unknown')}
        - Port: {recon_data.get('port', 'Unknown')}
        - Service: {recon_data.get('service', 'Unknown')}
        - Version: {recon_data.get('version', 'Unknown')}
        
        Requirements:
        1. Include proper error handling
        2. Add educational comments
        3. Include safety warnings
        4. Make it modular and readable
        5. Add timeout and connection limits
        6. Include ethical use disclaimer
        
        Generate complete, working Python code:
        """
        
    def _parse_exploit_response(self, response: str) -> Optional[Dict]:
        """Parse and validate exploit response"""
        try:
            # Extract code block if present
            code_match = re.search(r'```(?:python)?\n(.*?)\n```', response, re.DOTALL)
            if code_match:
                code = code_match.group(1)
            else:
                code = response
                
            # Validate Python syntax
            ast.parse(code)
            
            # Extract metadata
            metadata = {
                "code": code,
                "generated_at": datetime.now().isoformat(),
                "language": "python",
                "type": "poc"
            }
            
            # Try to extract additional info from comments
            if "CVE" in response:
                cve_match = re.search(r'CVE-\d{4}-\d+', response)
                if cve_match:
                    metadata["cve_id"] = cve_match.group(0)
                    
            return metadata
            
        except SyntaxError as e:
            self.logger.error(f"Invalid Python syntax in exploit: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Error parsing exploit response: {e}")
            return None
            
    def _save_exploit(self, exploit_data: Dict, cve_data: Dict) -> Path:
        """Save exploit to file"""
        cve_id = cve_data.get('cve_id', 'unknown')
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{cve_id}_{timestamp}.py"
        filepath = self.exploit_dir / filename
        
        # Add metadata as comments
        metadata = {
            "cve_id": cve_id,
            "generated_at": exploit_data["generated_at"],
            "type": exploit_data["type"]
        }
        
        content = f"""#!/usr/bin/env python3
# VulnForge Generated Exploit
# CVE: {cve_id}
# Generated: {exploit_data['generated_at']}
# Type: {exploit_data['type']}
# WARNING: For educational purposes only. Use responsibly.

{exploit_data['code']}
"""
        
        with open(filepath, 'w') as f:
            f.write(content)
            
        return filepath
        
    def generate_metasploit_module(self, exploit_data: Dict) -> Optional[Path]:
        """Generate Metasploit module from exploit"""
        prompt = f"""
        Convert this Python exploit to a Metasploit module:
        
        {exploit_data['code']}
        
        Requirements:
        1. Follow Metasploit module structure
        2. Include proper metadata
        3. Add error handling
        4. Include documentation
        """
        
        response = self.llm.query(
            prompt=prompt,
            system_prompt="""You are a Metasploit module developer.
            Convert exploits to proper Metasploit module format."""
        )
        
        if not response:
            return None
            
        # Save Metasploit module
        cve_id = exploit_data.get('cve_id', 'unknown')
        filename = f"{cve_id}.rb"
        filepath = self.exploit_dir / "metasploit" / filename
        filepath.parent.mkdir(exist_ok=True)
        
        with open(filepath, 'w') as f:
            f.write(response)
            
        return filepath
        
    def validate_exploit(self, exploit_data: Dict) -> Dict[str, Any]:
        """Validate generated exploit"""
        validation = {
            "syntax_valid": False,
            "has_error_handling": False,
            "has_safety_warnings": False,
            "has_timeout": False,
            "issues": []
        }
        
        try:
            # Check Python syntax
            ast.parse(exploit_data['code'])
            validation["syntax_valid"] = True
            
            # Check for error handling
            if "try:" in exploit_data['code'] and "except:" in exploit_data['code']:
                validation["has_error_handling"] = True
            else:
                validation["issues"].append("Missing error handling")
                
            # Check for safety warnings
            if "WARNING" in exploit_data['code'] or "CAUTION" in exploit_data['code']:
                validation["has_safety_warnings"] = True
            else:
                validation["issues"].append("Missing safety warnings")
                
            # Check for timeout
            if "timeout" in exploit_data['code']:
                validation["has_timeout"] = True
            else:
                validation["issues"].append("Missing timeout mechanism")
                
        except SyntaxError as e:
            validation["issues"].append(f"Syntax error: {str(e)}")
            
        return validation 